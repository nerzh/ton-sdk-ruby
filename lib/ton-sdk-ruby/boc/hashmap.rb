module TonSdkRuby

  class Hashmap
    extend TonSdkRuby

    attr_reader :hashmap, :key_size

    def initialize(key_size, options = {})
      serializers = options.fetch(:serializers, {})
      deserializers = options.fetch(:deserializers, {})

      @hashmap = {}
      @key_size = key_size
      @serialize_key = serializers.fetch(:key, -> (key) { key })
      @serialize_value = serializers.fetch(:value, -> (value) { value })
      @deserialize_key = deserializers.fetch(:key, -> (key) { key })
      @deserialize_value = deserializers.fetch(:value, -> (value) { value })
    end

    def each
      result = []
      @hashmap.each do |k, v|
        key = deserialize_key(k.chars.map(&:to_i))
        value = deserialize_value(v)

        result << (yield [key, value])
      end
      result
    end

    def get(key)
      k = serialize_key(key).join('')
      v = @hashmap[k]

      v.nil? ? nil : deserialize_value(v)
    end

    def has(key)
      !get(key).nil?
    end

    def set(key, value)
      k = serialize_key(key).join('')
      v = serialize_value(value)
      @hashmap[k] = v

      self
    end

    def add(key, value)
      has(key) ? self : set(key, value)
    end

    def replace(key, value)
      has(key) ? set(key, value) : self
    end

    def get_set(key, value)
      prev = get(key)
      set(key, value)
      prev
    end

    def get_add(key, value)
      prev = get(key)
      add(key, value)
      prev
    end

    def get_replace(key, value)
      prev = get(key)
      replace(key, value)
      prev
    end

    def delete(key)
      k = serialize_key(key).join('')
      hashmap.delete(k)
      self
    end

    def is_empty?
      hashmap.size == 0
    end

    def for_each(&callback)
      self.each { |key, value| callback.call(key, value) }
    end

    def get_raw(key)
      hashmap[key.join('')]
    end

    def set_raw(key, value)
      hashmap[key.join('')] = value
      self
    end

    def sort_hashmap
      sorted = hashmap.reduce([]) do |acc, (bitstring, value)|
        key = bitstring.chars.map(&:to_i)
        # Sort keys by DESC to serialize labels correctly later
        order = bitstring.to_i(2)
        lt = acc.find_index { |el| order > el[:order] }
        index = lt ? lt : acc.length

        acc.insert(index, { order: order, key: key, value: value })
      end

      sorted.map { |el| [el[:key], el[:value]] }
    end

    def serialize
      nodes = sort_hashmap

      if nodes.empty?
        raise 'Hashmap: can\'t be empty. It must contain at least 1 key-value pair.'
      end

      Hashmap.serialize_edge(nodes)
    end

    def self.serialize_edge(nodes)
      # hme_empty$0
      if nodes.empty?
        label = serialize_label_short([])

        return Builder.new
                      .store_bits(label)
                      .cell
      end

      edge = Builder.new
      label = serialize_label(nodes)

      edge.store_bits(label)

      # hmn_leaf#_
      if nodes.length == 1
        leaf = serialize_leaf(nodes[0])

        edge.store_slice(leaf.parse)
      end

      # hmn_fork#_
      if nodes.length > 1
        # Left edge can be empty, anyway we need to create hme_empty$0 to support right one
        left_nodes, right_nodes = serialize_fork(nodes)
        left_edge = serialize_edge(left_nodes)

        edge.store_ref(left_edge)

        unless right_nodes.empty?
          right_edge = serialize_edge(right_nodes)

          edge.store_ref(right_edge)
        end
      end

      edge.cell
    end

    def self.serialize_fork(nodes)
      # Serialize nodes to edges
      nodes.reduce([[], []]) do |acc, (key, value)|
        # Sort nodes by left/right edges
        acc[key.shift].push([key, value])

        acc
      end
    end

    def self.serialize_leaf(node)
      node[1]
    end

    def self.serialize_label(nodes)
      # Each label can always be serialized in at least two different fashions, using
      # hml_short or hml_long constructors. Usually the shortest serialization (and
      # in the case of a tieâ€”the lexicographically smallest among the shortest) is
      # preferred and is generated by TVM hashmap primitives, while the other
      # variants are still considered valid.

      # Get nodes keys
      first = nodes[0][0]
      last = nodes[nodes.length - 1][0]
      # m = length at most possible bits of n (key)
      m = first.length

      same_bits_index = nil
      first.each_with_index do |el, index|
        if el != last[index]
          same_bits_index = index
          break
        end
      end

      same_bits_length = same_bits_index.nil? ? first.length : same_bits_index

      if first[0] != last[0] || m == 0
        # hml_short for zero most possible bits
        return serialize_label_short([])
      end

      label = first[0, same_bits_length]
      repeated = label.join('').match(/(^0+)|(^1+)/)[0].split('').map { |b| b.to_i }
      label_short = serialize_label_short(label)
      label_long = serialize_label_long(label, m)
      label_same = nodes.length > 1 && repeated.length > 1 ? serialize_label_same(repeated, m) : nil

      labels = [
        { bits: label.length, label: label_short },
        { bits: label.length, label: label_long },
        { bits: repeated.length, label: label_same }
      ].reject { |el| el[:label].nil? }

      # Sort labels by their length
      labels.sort_by! { |el| el[:label].length }

      # Get most compact label
      choosen = labels[0]

      # Remove label bits from nodes keys
      nodes.each { |key, _| key.shift(choosen[:bits]) }

      choosen[:label]
    end

    def self.serialize_label_short(bits)
      label = Builder.new

      label.store_bit(0)
           .store_bits(bits.map { 1 })
           .store_bit(0)
           .store_bits(bits)

      label.bits
    end

    def self.serialize_label_long(bits, m)
      label = Builder.new

      label.store_bits([1, 0])
           .store_uint(bits.length, Math.log2(m + 1).ceil)
           .store_bits(bits)

      label.bits
    end

    def self.serialize_label_same(bits, m)
      label = Builder.new

      label.store_bits([1, 1])
           .store_bit(bits[0])
           .store_uint(bits.length, Math.log2(m + 1).ceil)

      label.bits
    end

    def self.deserialize(key_size, slice, options = {})
      if slice.bits.length < 2
        raise 'Hashmap: can\'t be empty. It must contain at least 1 key-value pair.'
      end

      hashmap = Hashmap.new(key_size, options)
      nodes = deserialize_edge(slice, key_size)

      nodes.each do |key, value|
        hashmap.set_raw(key, value)
      end

      hashmap
    end

    def self.deserialize_edge(edge, key_size, key = [])
      nodes = []

      key.concat(deserialize_label(edge, key_size - key.length))

      if key.length == key_size
        value = Builder.new.store_slice(edge).cell

        return nodes.concat([[key, value]])
      end

      edge.refs.each_with_index do |_r, i|
        fork_edge = edge.load_ref.parse
        fork_key = key + [i]

        nodes.concat(deserialize_edge(fork_edge, key_size, fork_key))
      end

      nodes
    end

    def self.deserialize_label(edge, m)
      # m = length at most possible bits of n (key)

      # hml_short$0
      if edge.load_bit == 0
        return deserialize_label_short(edge)
      end

      # hml_long$10
      if edge.load_bit == 0
        return deserialize_label_long(edge, m)
      end

      # hml_same$11
      deserialize_label_same(edge, m)
    end

    def self.deserialize_label_short(edge)
      length = edge.bits.index(0)
      edge.skip(length + 1)
      edge.load_bits(length)
    end

    def self.deserialize_label_long(edge, m)
      length = edge.load_uint(Math.log2(m + 1).ceil)
      edge.load_bits(length)
    end

    def self.deserialize_label_same(edge, m)
      repeated = edge.load_bit
      length = edge.load_uint(Math.log2(m + 1).ceil)
      Array.new(length) { repeated }
    end

    def cell
      serialize
    end

    def self.parse(key_size, slice, options = nil)
      deserialize(key_size, slice, options)
    end

    private

    def serialize_key(key)
      @serialize_key.call(key)
    end

    def serialize_value(value)
      @serialize_value.call(value)
    end

    def deserialize_key(key)
      @deserialize_key.call(key)
    end

    def deserialize_value(value)
      @deserialize_value.call(value)
    end
  end

  class HashmapE < Hashmap
    def initialize(key_size, options = nil)
      super(key_size, options)
    end

    protected

    def serialize
      nodes = sort_hashmap
      result = Builder.new

      if nodes.empty?
        result.store_bit(0).cell
      else
        result.store_bit(1).store_ref(HashmapE.serialize_edge(nodes)).cell
      end
    end

    def self.deserialize(key_size, slice, options = nil)
      if slice.bits.length != 1
        raise 'HashmapE: bad hashmap size flag.'
      end

      if slice.load_bit == 0
        HashmapE.new(key_size, options)
      else
        hashmap = HashmapE.new(key_size, options)
        edge = slice.load_ref.parse
        nodes = Hashmap.deserialize_edge(edge, key_size)

        nodes.each do |key, value|
          hashmap.set_raw(key, value)
        end

        hashmap
      end
    end

    def self.parse(key_size, slice, options = nil)
      deserialize(key_size, slice, options)
    end
  end

end
